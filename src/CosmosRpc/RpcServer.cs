//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.34209
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using NetMQ;
using NetMQ.Sockets;
using NLog;

namespace Cosmos.Rpc
{
    public class RpcServer : BaseNetMqServer
    {
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

        private RpcCaller _rpcCaller;
        public RpcServer(RpcCaller rpcCaller, string host = "0.0.0.0") : base(-1, host)
        {
            _rpcCaller = rpcCaller;
        }

        protected override async Task<byte[]> ProcessRequest(byte[] reqData)
        {
            var requestMsg = MsgPackTool.GetMsg<RequestMsg>(reqData);

            var resMsg = new ResponseMsg();
            resMsg.IsError = false;

            var method = _rpcCaller.GetType().GetMethod(requestMsg.FuncName);
            object executeResult = null;

            if (method != null)
            {
                var arguments = new object[requestMsg.Arguments.Length];
                for (var i = 0; i < arguments.Length; i++) // MsgPack.MessagePackObject arg in requestProto.Arguments)
                {
                    MsgPack.MessagePackObject arg = (MsgPack.MessagePackObject)requestMsg.Arguments[i];
                    arguments[i] = arg.ToObject();
                }
                try
                {
                    var result = method.Invoke(_rpcCaller, arguments);

                    if (result is Task)
                    {
                        executeResult = await (result as Task<object>);
                    }
                    else
                    {
                        executeResult = result;
                    }
                }
                catch (Exception e)
                {
                    resMsg.IsError = true;
                    resMsg.ErrorMessage = string.Format("[ERROR]Method '{0}' Exception: {1}", requestMsg.FuncName, e);
                    Logger.Error(resMsg.ErrorMessage);
                }
            }
            else
            {
                resMsg.IsError = true;
                resMsg.ErrorMessage = string.Format("[ERROR]Not found method: {0}", requestMsg.FuncName);
                Logger.Error(resMsg.ErrorMessage);
                Thread.Sleep(1);
            }

            resMsg.Value = executeResult;
            return MsgPackTool.GetBytes(resMsg);
        }

    }
    /// <summary>
    /// Any call RPC Fucntion must in this class
    /// </summary>
    public abstract class RpcCaller
    {
    }

    /// <summary>
    /// 使用ZeroMQ进行RPC
    /// </summary>
    //public class RpcServer : IDisposable
    //{
    //    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    //    public Poller Poller;
    //    private Task _pollerTask;

    //    internal NetMQContext _context;
    //    private ResponseSocket _server;
    //    public int Port { get; private set; }
    //    public string Host { get; private set; }

    //    object RpcInstace;

    //    public RpcServer(RpcCaller rpcInstance, string host = "0.0.0.0")
    //    {
    //        RpcInstace = rpcInstance;
    //        Poller = new Poller();
    //        Host = host;

    //        _context = NetMQContext.Create();
    //        _server = _context.CreateResponseSocket();

    //        Poller.AddSocket(_server);

    //        Port = _server.BindRandomPort("tcp://" + host);
    //        _server.ReceiveReady += OnReceiveReady;

    //        _pollerTask = Task.Run(() =>
    //        {
    //            Poller.Start();
    //        });
    //    }

    //    private void OnReceiveReady(object sender, NetMQSocketEventArgs e)
    //    {
    //        var data = _server.Receive();
    //        var req = RpcShare.RequestSerializer.UnpackSingleObject(data);

    //        ProcessRequest(req);
    //    }

    //    async void ProcessRequest(RequestMsg requestMsg)
    //    {
    //        var method = RpcInstace.GetType().GetMethod(requestMsg.FuncName);
    //        object executeResult = null;

    //        if (method != null)
    //        {
    //            var arguments = new object[requestMsg.Arguments.Length];
    //            for (var i = 0; i < arguments.Length; i++) // MsgPack.MessagePackObject arg in requestProto.Arguments)
    //            {
    //                MsgPack.MessagePackObject arg = (MsgPack.MessagePackObject)requestMsg.Arguments[i];
    //                arguments[i] = arg.ToObject();
    //            }
    //            var result = method.Invoke(RpcInstace, arguments);

    //            if (result is Task)
    //            {
    //                executeResult = await (result as Task<object>);
    //            }
    //            else
    //            {
    //                executeResult = result;
    //            }

    //        }
    //        else
    //        {
    //            Logger.Error("[ERROR]Not found method: {0}", requestMsg.FuncName);
    //            Thread.Sleep(1);
    //        }

    //        var data = RpcShare.ResponseSerializer.PackSingleObject(new ResponseMsg {
    //            RequestId = requestMsg.RequestId,
    //            Value = executeResult,
    //        });
    //        _server.Send(data);
    //    }


    //    public void Dispose()
    //    {
    //        Poller.RemoveSocket(_server);
    //        _server.Close();
    //        _context.Dispose();

    //        Poller.Stop();
    //        Poller.Dispose();
    //        _pollerTask.Dispose();
    //    }
    //}
}

